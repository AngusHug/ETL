#
### AC算法

* AC算法通过将模式串预处理为确定有限状态自动机，扫描文本一遍就能结束。其复杂度为O(n),即与模式串的数量和长度无关。

#### 一、经典AC算法
参考链接： https://www.hankcs.com/program/algorithm/implementation-and-analysis-of-aho-corasick-algorithm-in-java.html
AC算法中有三个核心函数，分别是：

1. success:成功转移到另一个状态；也称goto表或success表
2. failure:不可顺着字符串跳转的话，则跳转到一个特定的节点(也称failur表)，从根节点到这个特定节点的路径恰好是失败前的文本的一部分
3. emits：命中一个模式串(也称output表)
#### 二、算法匹配过程
##### 示例模式集{he,she,his,hers}
根据模式集构建字典树
![Image text](https://github.com/AngusHug/ETL/raw/master/Ahocorasick/img/img.png)

1. 首先尝试按succes表转义。按照文本的指示转移。
![Image text](https://github.com/AngusHug/ETL/raw/master/Ahocorasick/img/img[2].png)

* 每个节点对应状态，从状态0到状态9。定义状态转移函数g(i,c)=j表示指状态i读一个字符c转移到状态j，例如g(0,h)=1,g(1,e)=2
* 在简历字典树的时候同时建立转向函数


2. 失败了则按照failure表回去
* 失效函数：转向函数失效之后，程序所执行的函数。转向函数失效之后，失效函数将制定下一个状态
* 假设：以上图的状态转移图为准我们可以得到
```math
    g(2,'a') = -1,f(2)=0; g(0,'r')=-1,f(0)=0
```
* 若待匹配的字符串为"shis"，从状态0出发
    * * g(4,'i') = -1，但实际g(4,'i')应该可以跳到状态6。因为模式串中包含模式“his”。即可以得到f(4)=1,然后g(1,'i')=6可以完成状态4到状态6的跳转。
* 若待匹配字符串为"shers"，包含{"she","he","hers"}三个模式
* 当读到e的时候已经到了状态5，在读r就应该跳到2然后是3，及f(5)=2.可以得到
```math          
  g(3,'h')=4;g(0,'h') = 1;g(4,'e')=5 ;g(1,'e')=2
```
    * 引入深度d的概念，这里的深度和树中常说的深度是一个意思，例：d(1)=1,d(6)=2按如下步骤构建失效函数

    1. f(0) = 0
    2. d=1;
    3. 循环d直到d取最大深度(根据深度d-1的函数值，计算所有深度为d的函数值；d++)

* <u>对于3中：深度d-1的函数值，计算所有深度为d的函数值，即：对于状态9，g(8,s)=9，则f(9)=g(f(8),s)；根据递推式从深度d-1推到深度d的失效函数值</u>

![Image text](https://github.com/AngusHug/ETL/raw/master/Ahocorasick/img/img[3].png)
* **<u>若从状态i读取失败跳转到j，则可以理解为word[j]是word[i]的最长后缀(只包含后缀不包含完整单词)</u>**

|模式串|后缀|失败跳转(红色虚线)|备注|
|---|---|---|---|
|he|'e'|f('e',3)=0;f('e',8)=3;|she及匹配she又匹配he同时作为结果集|
|hers|'ers','rs','s'|f('h',1)=0;f('e',3)=0;f('r',6)=0;f('s',9)=2||
|his|'is','s'|f('h',1)=0;f('i',4)=0;f('s',7)=2||
|she|'he','e'|f('h',5)=1;f('e',8)=3||

3. 成功了继续按success表转移，知道失败跳到步骤2，或者遇到output表中表明的可输出状态。此时输出匹配到的模式串，然后将此状态是做普通的状态继续转移
    * 输出函数：通过转向函数和失效函数可以实现AC自动机一个个的读入字符，然后进行状态跳转。此时需要输出结果的函数。
        * 跳到状态2：输出he
        * 跳到状态5：输出she和he

    * 在建立转向函数g的时候，可以建立输出函数，output(2)="he",output(9)="hers"等。在建立失效函数的时候更新输出函数。具体来说，当我们发现f(s)=s'的时候，有output(s) = output(s)Uoutput(s')。例如f(5)=2，啧output(5) = output(5) U output(2)={"she","he"}
### 预处理过程(fail指针+exists单词信息(output函数))
|类型|demo|
|---|---|
|P(模式串)|{he,she,hers,his}|
|T|ahishers|


1. 根据P串构建字典树
* 在某个模式串结点结尾可以知道该节点结束存储的是哪一个单词
    * 例如结点3可以知道存储的是单词“he”

2. 构建fail指针(例如层次遍历 来遍历字典树)
* 结点,2的fail指针，因为只有一个字母所以没有前缀和后缀(温习KMP)
* 结点3：其父亲结点的fail指针指向结点0，而结点0没有以e为止的节点(即e的儿子)；所以节点3fail指针指向0
* 节点4：对应hi，4号节点父亲2号节点父亲指针指向节点0，而结点0没有儿子结点i；所以节点4fail指针指向root
* 节点5:5号节点的父亲结点2的fail指针指向节点0，而结点0的h后缀儿子结点为2号节点，所以5号节点的fail指针指向节点2

3. 实例：查找ahishers中的模式

* a:为空
* h:从root到1号节点，但并不是p串
* i:经过i到节点4
* s：经过s到节点7 ====节点7存储exists[]=3；即存储长度为3的一个单词。及可以存查找的T串所在的索引往前三个长度即得到一个单词
* h:节点7没有h的儿子结点通过fail指针移动到2号节点；到2号节点就只有s公共的后缀，2号节点走h后缀到5号节点
* e：到节点8 得到exists[]=3；即从8号节点的三个得到长度为3的单词；同时有exists[]=2 即得到长度为2的单词
* r:没有子节点 通过fail指针到3号节点 有儿子r到节点6
* s:经过s到节点9 得到exists=4，及得到长度为4的单词

#
### 普通DFA算法
DFA算法，确定性有穷自动机，用于正则表达式的匹配，最长左子式匹配(DFA就是通过当前状态、动作获取下一个状态)。



